# Application Configuration
spring.application.name=aml-fraud-detector
server.port=${SERVER_PORT:8080}
server.servlet.context-path=${CONTEXT_PATH:/api/v1}

# Tomcat Thread Pool Configuration (Ultra High Throughput - 30K+ requests)
server.tomcat.threads.min-spare=${TOMCAT_MIN_SPARE:200}
server.tomcat.threads.max=${TOMCAT_MAX_THREADS:1000}
server.tomcat.max-connections=${TOMCAT_MAX_CONNECTIONS:10000}
server.tomcat.accept-count=${TOMCAT_ACCEPT_COUNT:5000}
server.tomcat.connection-timeout=${TOMCAT_CONNECTION_TIMEOUT:20000}
server.tomcat.keep-alive-timeout=${TOMCAT_KEEPALIVE_TIMEOUT:60000}
server.tomcat.max-keep-alive-requests=${TOMCAT_MAX_KEEPALIVE:1000}

# HTTP/2 Support - Dynamic Auto-Detection and Failover
server.http2.enabled=${HTTP2_ENABLED:false}

# HTTP/2 Auto-Detection Configuration
http2.auto.detect.enabled=${HTTP2_AUTO_DETECT_ENABLED:true}
http2.detection.test.url=${HTTP2_DETECTION_TEST_URL:http://localhost:8080/actuator/health}
http2.detection.timeout.ms=${HTTP2_DETECTION_TIMEOUT:5000}
http2.detection.refresh.interval.seconds=${HTTP2_DETECTION_REFRESH_INTERVAL:300}

# HTTP/2 Health Monitoring Configuration
http2.health.monitoring.enabled=${HTTP2_HEALTH_MONITORING_ENABLED:true}
http2.health.check.interval.seconds=${HTTP2_HEALTH_CHECK_INTERVAL:30}
http2.failover.drop.threshold=${HTTP2_FAILOVER_DROP_THRESHOLD:10}
http2.failover.error.rate.threshold=${HTTP2_FAILOVER_ERROR_RATE_THRESHOLD:0.05}
http2.failover.latency.threshold.ms=${HTTP2_FAILOVER_LATENCY_THRESHOLD:1000}

# HTTP/2 Failover Configuration
http2.failover.enabled=${HTTP2_FAILOVER_ENABLED:true}
http2.failover.retry.interval.seconds=${HTTP2_FAILOVER_RETRY_INTERVAL:300}
http2.failover.min.retry.interval.seconds=${HTTP2_FAILOVER_MIN_RETRY_INTERVAL:60}
http2.failover.auto.retry.enabled=${HTTP2_FAILOVER_AUTO_RETRY_ENABLED:true}

# HTTP/2 Network Stability Configuration (Background Process)
http2.network.stability.enabled=${HTTP2_NETWORK_STABILITY_ENABLED:true}
http2.network.stability.check.interval.seconds=${HTTP2_NETWORK_STABILITY_CHECK_INTERVAL:30}
http2.network.stability.test.url=${HTTP2_NETWORK_STABILITY_TEST_URL:http://localhost:8080/actuator/health}
http2.network.stability.timeout.ms=${HTTP2_NETWORK_STABILITY_TIMEOUT:5000}
http2.network.stability.success.threshold=${HTTP2_NETWORK_STABILITY_SUCCESS_THRESHOLD:5}
http2.network.stability.failure.threshold=${HTTP2_NETWORK_STABILITY_FAILURE_THRESHOLD:3}

# Compression
server.compression.enabled=${COMPRESSION_ENABLED:true}
server.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain
server.compression.min-response-size=1024

# Database Configuration (PostgreSQL)
spring.datasource.url=${DATABASE_URL:jdbc:postgresql://localhost:5432/aml_fraud_db}
spring.datasource.username=${DATABASE_USERNAME:postgres}
spring.datasource.password=${POSTGRES_DATABASE_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

# Aerospike Configuration (Sanctions Screening Database)
aerospike.enabled=${AEROSPIKE_ENABLED:true}
aerospike.hosts=${AEROSPIKE_HOSTS:localhost:3000}
aerospike.namespace=test
aerospike.security.enabled=${AEROSPIKE_SECURITY_ENABLED:false}
aerospike.username=${AEROSPIKE_USERNAME:}
aerospike.password=${AEROSPIKE_PASSWORD:}
aerospike.connection.timeout=${AEROSPIKE_CONNECTION_TIMEOUT:5000}
aerospike.connection.timeout.ms=5000
aerospike.max.socket.idle=${AEROSPIKE_MAX_SOCKET_IDLE:55}
aerospike.max.connections=300
aerospike.tend.interval=${AEROSPIKE_TEND_INTERVAL:1000}
aerospike.connection.health.check.interval.seconds=${AEROSPIKE_HEALTH_CHECK_INTERVAL:30}
aerospike.connection.keepalive.enabled=${AEROSPIKE_KEEPALIVE_ENABLED:true}
aerospike.auto.init.enabled=${AEROSPIKE_AUTO_INIT_ENABLED:true}
aerospike.auto.init.wait.seconds=${AEROSPIKE_AUTO_INIT_WAIT:10}

# JPA Configuration (Ultra High Throughput - 30K+ requests)
spring.jpa.hibernate.ddl-auto=${JPA_DDL_AUTO:update}
spring.jpa.show-sql=${JPA_SHOW_SQL:false}
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=${JPA_FORMAT_SQL:true}
spring.jpa.properties.hibernate.jdbc.batch_size=${JPA_BATCH_SIZE:200}
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true
spring.jpa.properties.hibernate.jdbc.batch_fetch_style=${JPA_BATCH_FETCH:legacy}
spring.jpa.properties.hibernate.generate_statistics=false
spring.jpa.properties.hibernate.query.plan_cache_max_size=${JPA_QUERY_CACHE:2048}
spring.jpa.properties.hibernate.query.plan_parameter_metadata_max_size=${JPA_PARAM_CACHE:128}
spring.jpa.open-in-view=false
spring.jpa.properties.hibernate.connection.provider_disables_autocommit=true

# HikariCP Connection Pool Configuration (Ultra High Throughput - 30K+ requests)
spring.datasource.hikari.minimum-idle=${HIKARI_MIN_IDLE:100}
spring.datasource.hikari.maximum-pool-size=${HIKARI_MAX_POOL_SIZE:300}
spring.datasource.hikari.connection-timeout=${HIKARI_CONNECTION_TIMEOUT:20000}
spring.datasource.hikari.idle-timeout=${HIKARI_IDLE_TIMEOUT:300000}
spring.datasource.hikari.max-lifetime=${HIKARI_MAX_LIFETIME:1800000}
spring.datasource.hikari.leak-detection-threshold=${HIKARI_LEAK_DETECTION:60000}
spring.datasource.hikari.pool-name=AMLFraudDetectorPool
spring.datasource.hikari.auto-commit=false
spring.datasource.hikari.initialization-fail-timeout=-1
spring.datasource.hikari.validation-timeout=3000
spring.datasource.hikari.isolate-internal-queries=false
spring.datasource.hikari.register-mbeans=true
spring.datasource.hikari.allow-pool-suspension=false
spring.datasource.hikari.read-only=false

# Logging Configuration
logging.level.root=${LOG_LEVEL:INFO}
logging.level.com.posgateway.aml=${LOG_LEVEL_AML:DEBUG}
logging.pattern.console=${LOG_PATTERN:%d{yyyy-MM-dd HH:mm:ss} - %msg%n}
logging.file.name=logs/aml-system-errors.log
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# AML Configuration
aml.enabled=${AML_ENABLED:true}
aml.risk.threshold.low=${AML_RISK_THRESHOLD_LOW:30}
aml.risk.threshold.medium=${AML_RISK_THRESHOLD_MEDIUM:60}
aml.risk.threshold.high=${AML_RISK_THRESHOLD_HIGH:80}

# Fraud Detection Configuration
fraud.enabled=${FRAUD_ENABLED:true}
fraud.scoring.enabled=${FRAUD_SCORING_ENABLED:true}
fraud.scoring.threshold=${FRAUD_SCORING_THRESHOLD:70}
fraud.velocity.check.enabled=${FRAUD_VELOCITY_CHECK:true}
fraud.velocity.window.minutes=${FRAUD_VELOCITY_WINDOW:60}
fraud.velocity.max.transactions=${FRAUD_VELOCITY_MAX_TX:10}

# Transaction Monitoring Configuration
transaction.monitoring.enabled=${TX_MONITORING_ENABLED:true}
transaction.monitoring.batch.size=${TX_MONITORING_BATCH_SIZE:100}
transaction.monitoring.interval.seconds=${TX_MONITORING_INTERVAL:300}

# Alert Configuration
alert.enabled=${ALERT_ENABLED:true}
alert.email.enabled=${ALERT_EMAIL_ENABLED:false}
alert.email.recipients=${ALERT_EMAIL_RECIPIENTS:}
alert.webhook.enabled=${ALERT_WEBHOOK_ENABLED:false}
alert.webhook.url=${ALERT_WEBHOOK_URL:}

# External Service Configuration
external.service.timeout.seconds=${EXTERAL_SERVICE_TIMEOUT:30}
external.service.retry.max=${EXTERNAL_SERVICE_RETRY_MAX:3}
external.service.retry.delay.seconds=${EXTERNAL_SERVICE_RETRY_DELAY:5}

# Actuator Configuration
management.endpoints.web.exposure.include=${ACTUATOR_ENDPOINTS:health,info,metrics,prometheus}
management.endpoint.health.show-details=${ACTUATOR_HEALTH_DETAILS:when-authorized}
management.endpoint.prometheus.enabled=true
management.metrics.export.prometheus.enabled=true
management.metrics.export.prometheus.step=10s
management.metrics.tags.application=${spring.application.name}
management.metrics.tags.environment=${ENVIRONMENT:development}

# Security Configuration (for future implementation)
security.enabled=${SECURITY_ENABLED:true}
security.jwt.secret=${JWT_SECRET:}
security.jwt.expiration.ms=${JWT_EXPIRATION:3600000}

# Disable Spring Security for testing
spring.security.enabled=false
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration

# Redis Configuration
redis.enabled=${REDIS_ENABLED:false}
redis.host=${REDIS_HOST:localhost}
redis.port=${REDIS_PORT:6379}
redis.password=${REDIS_PASSWORD:}
redis.database=${REDIS_DATABASE:0}
redis.timeout=${REDIS_TIMEOUT:2000}
redis.auto.init.enabled=${REDIS_AUTO_INIT_ENABLED:true}
redis.keys.prefix=${REDIS_KEYS_PREFIX:aml}

# Redis Connection Pool
spring.data.redis.host=${REDIS_HOST:localhost}
spring.data.redis.port=${REDIS_PORT:6379}
spring.data.redis.password=${REDIS_PASSWORD:}
spring.data.redis.database=${REDIS_DATABASE:0}
spring.data.redis.timeout=${REDIS_TIMEOUT:2000}
spring.data.redis.lettuce.pool.max-active=${REDIS_POOL_MAX_ACTIVE:200}
spring.data.redis.lettuce.pool.max-idle=${REDIS_POOL_MAX_IDLE:20}
spring.data.redis.lettuce.pool.min-idle=${REDIS_POOL_MIN_IDLE:5}
spring.data.redis.lettuce.pool.max-wait=${REDIS_POOL_MAX_WAIT:-1}

# Cache Configuration (Redis if enabled, otherwise Caffeine)
spring.cache.type=${CACHE_TYPE:simple}
spring.cache.cache-names=modelConfig,aggregateFeatures
spring.cache.caffeine.spec=maximumSize=10000,expireAfterWrite=300s

# Scoring Service Configuration
scoring.service.enabled=${SCORING_SERVICE_ENABLED:true}
scoring.service.url=${SCORING_SERVICE_URL:http://localhost:8000}
scoring.service.timeout.ms=${SCORING_SERVICE_TIMEOUT:200}
scoring.service.retry.max=${SCORING_SERVICE_RETRY_MAX:3}

# REST Assured Configuration
rest.assured.timeout.ms=${REST_ASSURED_TIMEOUT:200}

# HTTP Connection Pool Configuration (30K+ simultaneous connections)
http.connection.pool.max.total=${HTTP_MAX_TOTAL:30000}
http.connection.pool.max.per.route=${HTTP_MAX_PER_ROUTE:5000}
http.connection.pool.validate.after.inactivity=${HTTP_VALIDATE_INACTIVITY:2000}
http.connection.timeout=${HTTP_CONNECTION_TIMEOUT:5000}
http.socket.timeout=${HTTP_SOCKET_TIMEOUT:10000}
http.connection.request.timeout=${HTTP_REQUEST_TIMEOUT:5000}

# Async Processing Configuration
async.core.pool.size=${ASYNC_CORE_POOL_SIZE:50}
async.max.pool.size=${ASYNC_MAX_POOL_SIZE:200}
async.queue.capacity=${ASYNC_QUEUE_CAPACITY:1000}
async.thread.name.prefix=${ASYNC_THREAD_PREFIX:aml-async-}

# Ultra High Throughput Configuration (30K+ concurrent requests)
ultra.throughput.core.pool.size=${ULTRA_CORE_POOL_SIZE:500}
ultra.throughput.max.pool.size=${ULTRA_MAX_POOL_SIZE:2000}
ultra.throughput.queue.capacity=${ULTRA_QUEUE_CAPACITY:10000}

# Cache Configuration (High Throughput)
cache.aggregate.max.size=${CACHE_AGGREGATE_MAX_SIZE:100000}
cache.aggregate.expire.minutes=${CACHE_AGGREGATE_EXPIRE:60}
cache.config.max.size=${CACHE_CONFIG_MAX_SIZE:1000}
cache.config.expire.minutes=${CACHE_CONFIG_EXPIRE:30}

# Resilience4j Circuit Breaker Configuration
resilience4j.circuitbreaker.configs.default.failure-rate-threshold=${CIRCUIT_BREAKER_FAILURE_RATE:50}
resilience4j.circuitbreaker.configs.default.wait-duration-in-open-state=${CIRCUIT_BREAKER_WAIT_DURATION:10s}
resilience4j.circuitbreaker.configs.default.sliding-window-size=${CIRCUIT_BREAKER_WINDOW_SIZE:10}
resilience4j.circuitbreaker.configs.default.minimum-number-of-calls=${CIRCUIT_BREAKER_MIN_CALLS:5}

# High Throughput Optimizations
throughput.batch.size=${THROUGHPUT_BATCH_SIZE:100}
throughput.parallel.feature.extraction=${THROUGHPUT_PARALLEL_FEATURES:true}
throughput.enable.async.processing=${THROUGHPUT_ASYNC_ENABLED:true}

# Ultra High Throughput Configuration (30K+ concurrent requests)
ultra.throughput.enabled=${ULTRA_THROUGHPUT_ENABLED:true}
ultra.throughput.request.buffer.size=${ULTRA_REQUEST_BUFFER_SIZE:50000}
ultra.throughput.batch.processing.size=${ULTRA_BATCH_SIZE:500}
ultra.throughput.enable.reactive=${ULTRA_REACTIVE_ENABLED:false}
ultra.throughput.max.concurrent.requests=${ULTRA_MAX_CONCURRENT:30000}
ultra.throughput.max.requests.per.second=${ULTRA_MAX_REQUESTS_PER_SECOND:50000}

# Feature Extraction Configuration
feature.extraction.enabled=${FEATURE_EXTRACTION_ENABLED:true}
feature.aggregate.cache.enabled=${FEATURE_AGGREGATE_CACHE:true}
feature.velocity.window.hours=${FEATURE_VELOCITY_WINDOW_HOURS:1}
feature.velocity.window.days=${FEATURE_VELOCITY_WINDOW_DAYS:7}

# Transaction Statistics Service Configuration
transaction.stats.key.prefix=${TRANSACTION_STATS_KEY_PREFIX:aml:stats}
transaction.stats.ttl.hours=${TRANSACTION_STATS_TTL_HOURS:168}

# ================================================================================================
# MERCHANT AML SANCTIONS SCREENING CONFIGURATION
# ================================================================================================

# Aerospike Sanctions Database (Tier 2 - Local Screening)
aerospike.namespace=test
aerospike.connection.timeout.ms=5000
aerospike.max.connections=300

# Sanctions Download Service (OpenSanctions)
sanctions.download.enabled=true
sanctions.download.cron=0 0 2 * * *
sanctions.download.temp.dir=C:/temp/sanctions
sanctions.opensanctions.url=https://data.opensanctions.org/datasets/latest/sanctions/targets.nested.json
sanctions.opensanctions.metadata.url=https://data.opensanctions.org/datasets/latest/sanctions/index.json

# Name Matching Configuration
sanctions.matching.levenshtein.threshold=3
sanctions.matching.similarity.threshold=0.8
sanctions.matching.phonetic.maxlength=10

# Screening Cache (Aerospike)
sanctions.cache.enabled=true
sanctions.cache.ttl.hours=24

# Merchant Rescreening Configuration
rescreening.enabled=true
rescreening.frequency.days=7
rescreening.cron=0 0 3 * * *

# Sumsub External AML Provider (Tier 1 - New Merchants)
# IMPORTANT: Set these as environment variables for security
# Example: export SUMSUB_ENABLED=true
#          export SUMSUB_API_KEY=your_app_token_here
#          export SUMSUB_API_SECRET=your_secret_key_here
sumsub.enabled=${SUMSUB_ENABLED:true}
sumsub.api.url=https://api.sumsub.com/resources
sumsub.api.key=${SUMSUB_API_KEY}
sumsub.api.secret=${SUMSUB_API_SECRET}
sumsub.cost.per.check=1.85

# Resilience4j Configuration for Sumsub
resilience4j.circuitbreaker.instances.sumsub.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.sumsub.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.sumsub.sliding-window-size=10
resilience4j.circuitbreaker.instances.sumsub.minimum-number-of-calls=5

resilience4j.retry.instances.sumsub.max-attempts=3
resilience4j.retry.instances.sumsub.wait-duration=1s
resilience4j.retry.instances.sumsub.exponential-backoff-multiplier=2

resilience4j.timelimiter.instances.sumsub.timeout-duration=10s

resilience4j.ratelimiter.instances.sumsub.limit-for-period=100
resilience4j.ratelimiter.instances.sumsub.limit-refresh-period=1s

# Risk Scoring Configuration (pulled from model_config table, but defaults here)
risk.threshold.approve=30
risk.threshold.review=50
risk.threshold.edd=50
risk.threshold.reject=80

# High-Risk Configuration
risk.country.high_risk=AF,IR,KP,SY,YE,MM,VE,ZW
risk.mcc.high_risk=6211,7995,7273,5993,6051
risk.volume.threshold=100000000
risk.business.new_months=6

# Compliance Case Management
compliance.cases.sla.hours=48
compliance.cases.auto.assign.enabled=false
compliance.cases.escalation.hours=72

# Security & Encryption
security.encryption.key=${ENCRYPTION_KEY}
security.encryption.algorithm=AES-256-GCM
security.pii.masking.enabled=true

# Audit Trail
audit.trail.enabled=true
audit.trail.store.ip.address=true
audit.trail.store.user.agent=true

